brute : 일단 버블소트 구현 후 swap 카운팅 -> 시간초과



이걸 분할정복으로 어케하노 ㅋㅋ


Bubble Sort : 순차탐색하면서 가장 큰 값을 greedy 하게 뒤로 보내는 방법

퀵소트 -> 인덱스 비교..?

for(int index = 1; i <= n; i++){
 1. 이진탐색으로 정렬배열[index] 가 안정렬배열의 몇번쨰(t)인지 구함
 2. int cntTemp = index - t;
 3. if(cntTemp > 0) cnt += cntTemp;
}

1 4 7 2 6
1 2 4 6 7

---> 정돈된 배열의 size가 계속 바뀌어서 불가능

=========================

vector로 받고
for(int size = n; i >= 1; i--){
 1. max_element() 찾고
 2. 인덱스 값 빼서 cnt에 더하고
 3. vector에서 erase();

-> 시간초과

==================

입력받을때 인덱스도 묶어서 넣는다면..?

i
3	3 - 1 = 2
2	2 - (2 - 1) = 1
1	1 - (3 - 2) = 0


if(sec > i) i - (sec - (n - i))
else i - sec
i
5	5 - 3 = 2
4	4 - (5 - 1hn) = 0
3	3 - 2 = 1
2	2 - (4 - 2) = 1

======================

각 시행마다
1 4 7 2 6
1 4 2 6
1 4 2
1 2
1

3 2 1
2 1
1

최대값이 마지막 인덱스로부터 얼마나 떨어져 있는지를 구해야함

Prob 	1. 최대값을 어떻게 구할지?
	2. 각 시행마다 최대값만을 빼고 순서를 유지하는 배열을 어떻게 만들지?


1. for문 한번 돌리면서 각 index마다 stack에 넣으면?

1 1
4 4 1
7 7 4 1
2 7 4 2 1 <- 이런 연산때문에 시간초과뜰듯
6

1. 나보다 작거나 같은 value 만 넣은 배열?

만들 방법이 없음

2. 세그먼트 트리?
		 ---(1,1)
		 |
	--(2,4)--|
	|	 |
	|	 ---(2,4)
(3,7)---|		  ----(3,7)
	|	 --(3,7)--|
	|	 |	  |
	--(3,7)--|	  ----(4,2)
		 |
		 ---(5,6)
 보단 max_heap 이 나을듯

for(int size = n; size >= 1; size--){
	size - heap.front().second


Prob	3. 1로 최대값을 뺄때마다 남아있는 element들의 index를 갱신해야함
	만약 500,000개 데이터가 내림차순으로 입력되면
	갱신작업은 무조건 500,000 * 500,0000

	갱신을 하지 않고 최대값의 swap 카운트를 할 수 있어야함
	
	
============================

for문을 돌리면서 내 뒤에 있는 애들 중 나보다 작은 애들의 개수


